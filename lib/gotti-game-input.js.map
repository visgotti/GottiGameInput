{"version":3,"sources":["webpack://GottiGameInput/webpack/universalModuleDefinition","webpack://GottiGameInput/webpack/bootstrap","webpack://GottiGameInput/./src/Core/Systems/InputSystem.ts","webpack://GottiGameInput/./src/utils.ts","webpack://GottiGameInput/./src/index.ts","webpack://GottiGameInput/./src/Core/GameInput.ts","webpack://GottiGameInput/./src/Core/Managers/ControllerManager.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/ControllerSystems/index.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/ControllerSystems/DefaultController.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/BaseControllerSystem.ts","webpack://GottiGameInput/./src/Core/Managers/BaseManager.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/KeyboardSystem.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/MouseSystem.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","mappedActionToInputIds","_onActionListeners","_onMappedActionAddedListeners","_onMappedActionRemovedListeners","actionState","actionNames","mappedInputIdToActions","this","applyActionToInputMap","validateActionToInputMap","Error","action","addActionState","forEach","input","mapInputIdToAction","prevState","updateState","changed","length","curAction","previous","current","changeObj","state","filter","actionName","keys","cb","push","listeners","idx","indexOf","splice","inputId","actions","eventData","actionNowUnmapped","idx1","cur","includes","dup","k","RADIAN_TO_DEGREE_MULTIPLIER","Math","PI","DEGREE_TO_RADIAN_MULTIPLIER","x","y","abs","angles","power","radians","atan2","degrees","north0Degrees","default","north0","max","direction","rounded","round","mappedInputStates","disableOpts","updateController","updateKeyboard","updateTouch","updateMouse","keyboard","initializeKeyboardSystem","mouse","initializeMouseManager","controller","initializeControllerManager","touch","system","keyboardSystem","KeyboardSystem","update","touchSystem","mouseSystem","MouseSystem","controllerManager","ControllerManager","on","console","error","init","BaseManager","super","needsPolling","trackedSystemArray","initializedSystemArray","navigator","removeEventListener","handleGamePadConnected","handleGamePadDisconnected","gamepad","every","pollGamepads","addEventListener","e","gpIdx","index","gp","getGamepads","controllerSystemFactory","addSystem","trackedSystem","initIndex","removeSystem","gamepads","gamePadSystemInitialized","connected","g","DefaultController","BaseControllerSystem","sticks","left","mapStickToAction","updateStickState","stickIndex","isPressed","movedMap","mappedStickActions","move","pressedMap","press","stickX","parseFloat","axes","toFixed","stickY","normalizeAxes","dir22","getDirectionFromNorth0Degrees","log","dir","stringDirections","a","degreeDirections","min","isStickPressed","InputSystem","stickActionCount","_onMappedStickActionAddedListeners","_onMappedStickActionRemovedListeners","mappedStickRotationActions","mappedAxesActions","axesIndex","start","end","callback","stickAction","Array","isArray","unmapStickFromAction","type","validateStickActionType","stickActions","getStickActionLookup","actionString","updateStickActionCount","actionIsMapped","found","find","isPress","createIfNotAdded","add","isValidDirection","validateMinMax","sort","aa","bb","btnIndex","buttons","b","resolvedBtnActions","resolveActions","makeButtonId","pressed","hasMin","hasMax","managedSystems","_systemListeners","remove","onUpdate","map","onClear","eventname","actionsFinished","actionsStarted","handleKeyDown","handleKeyUp","event","code","handleMouseDown","handleMouseUp","handleMouseMove","button"],"mappings":"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","file":"gotti-game-input.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GottiGameInput\"] = factory();\n\telse\n\t\troot[\"GottiGameInput\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { ActionStateDatumChange, AddInputIdActionMapEvent, RemoveInputIdActionMapEvent, MappedActionToInputState, UpdatedSystemActionState } from \"../types\";\r\n\r\ntype ActionState = {[actionName: string]: boolean | number }\r\n\r\n// type: 'controller' | 'mouse' | 'keyboard' | 'touch'\r\n\r\nexport abstract class InputSystem {\r\n    private _onActionListeners: {[actionName: string]: Array<(event: ActionStateDatumChange) => void>} = {}\r\n    protected _onMappedActionAddedListeners: Array<(event: AddInputIdActionMapEvent) => void> = [];\r\n    protected _onMappedActionRemovedListeners: Array<(event: RemoveInputIdActionMapEvent) => void> = [];\r\n\r\n    readonly actionState: {[actionName: string]: boolean } = {};\r\n    private actionNames: Array<string> = [];\r\n\r\n    protected mappedInputIdToActions: MappedActionToInputState = {};\r\n    protected mappedActionToInputIds: MappedActionToInputState = {};\r\n  //   protected mappedActionToOrderedInputCombos : {[action: string]: Array<string>}\r\n  //  protected mappedActionToUnorderedInputCombos : {[action: string]: Array<string>}\r\n    // protected inputToActionCombos : {[inputId: string]: Array<actionCombo> }\r\n\r\n    constructor(mappedActionToInputIds?: MappedActionToInputState) {\r\n        mappedActionToInputIds && this.applyActionToInputMap(mappedActionToInputIds);\r\n    }\r\n    protected applyActionToInputMap(mappedActionToInputIds: {[action: string]: Array<string> }) {\r\n        if(!this.validateActionToInputMap(mappedActionToInputIds)) throw new Error(`Invalid.`);\r\n        for(let action in mappedActionToInputIds) {\r\n            this.addActionState(action, false);\r\n            mappedActionToInputIds[action].forEach(input => {\r\n                this.mapInputIdToAction(input, action);\r\n            });\r\n        }\r\n    }\r\n    public getMappedActionInputs() : MappedActionToInputState {\r\n        return { ...this.mappedActionToInputIds };\r\n    }\r\n    private validateActionToInputMap(mappedActionToInputIds: {[action: string]: Array<string> }) : boolean {\r\n        //todo:... make sure nothing gets removed when it shouldnt.\r\n        return true;\r\n    }\r\n    public abstract onClear() : void;\r\n    public abstract updateState() : void;\r\n\r\n    public update() : UpdatedSystemActionState {\r\n        const prevState = { ...this.actionState };\r\n        this.updateState();\r\n        let changed : {[action:string]: ActionStateDatumChange }  = null;\r\n        for(let i = 0; i < this.actionNames.length; i++) {\r\n            const curAction = this.actionNames[i];\r\n            const previous = prevState[curAction];\r\n            const current = this.actionState[curAction]\r\n            if(previous !== current) {\r\n                changed = changed || {};\r\n                const changeObj = { previous, current };\r\n                changed[curAction] = changeObj;\r\n                this._onActionListeners[curAction]?.forEach(l => l(changeObj));\r\n            }\r\n        }\r\n        return { state: this.actionState, changed };\r\n    }\r\n\r\n    public getUnmappedActions() : Array<string> {\r\n        return this.actionNames.filter(n => {\r\n            return !(n in this.mappedActionToInputIds);\r\n        })\r\n    }\r\n\r\n    protected handleActionChange(actionName: string, value: boolean) {\r\n        if(!(actionName in this.actionState)) throw new Error(`Invalid action changed ${actionName}`)\r\n    }\r\n    public addActionState(action: string, value=false) {\r\n        if(action in this.actionState) throw new Error(`Already added action ${action}`);\r\n        this.actionState[action] = value;\r\n        this.actionNames = Object.keys(this.actionState);\r\n    }\r\n    public removeActionState(action: string) {\r\n        if(!(action in this.actionState)) throw new Error(`No action added: ${action}`);\r\n        delete this.actionState[action];\r\n        this.actionNames = Object.keys(this.actionState);\r\n    }\r\n    public onActionChange(actionName: string, cb: (event: ActionStateDatumChange) => void) {\r\n        if(this._onActionListeners[actionName]) {\r\n            this._onActionListeners[actionName].push(cb);\r\n        } else {\r\n            this._onActionListeners[actionName] = [cb]\r\n        }\r\n    }\r\n    public offActionChange(actionName: string, cb: (event: ActionStateDatumChange) => void) {\r\n        const listeners = this._onActionListeners[actionName];\r\n        if(listeners) {\r\n            const idx = listeners.indexOf(cb)\r\n            idx > -1 && listeners.splice(idx, 1);\r\n            if(!listeners.length) {\r\n                delete this._onActionListeners[actionName];\r\n            }\r\n        }\r\n    }\r\n    public onMappedActionAdded(cb: (event: AddInputIdActionMapEvent) => void) : number {\r\n        return this._onMappedActionAddedListeners.push(cb);\r\n    }\r\n    public offMappedActionAdded(cb: (payload: AddInputIdActionMapEvent) => void) : number {\r\n        const idx = this._onMappedActionAddedListeners.push(cb);\r\n        idx > -1 && this._onMappedActionAddedListeners.splice(idx, 1);\r\n        return this._onMappedActionAddedListeners.length;\r\n    }\r\n    public onMappedActionRemoved(cb: (event: RemoveInputIdActionMapEvent) => void) : number {\r\n        return this._onMappedActionRemovedListeners.push(cb);\r\n    }\r\n    public offMappedActionRemoved(cb: (payload: RemoveInputIdActionMapEvent) => void) : number {\r\n        const idx = this._onMappedActionRemovedListeners.indexOf(cb)\r\n        idx > -1 && this._onMappedActionRemovedListeners.splice(idx, 1);\r\n        return this._onMappedActionRemovedListeners.length;\r\n    }\r\n\r\n    protected unmapInputFromAction(inputId: string, action: string) : RemoveInputIdActionMapEvent {\r\n        const actions = this.mappedInputIdToActions[inputId];\r\n        if(typeof actions === 'undefined') {\r\n            throw new Error(`The inputId ${inputId} was not mapped to any action.`)\r\n        }\r\n        const eventData : RemoveInputIdActionMapEvent = { inputId, action, actionNowUnmapped: false };\r\n        const idx1 = actions.indexOf(action);\r\n        if(idx1 < 0) {\r\n            throw new Error(`The inputId ${inputId} was not mapped to action ${action}.`)\r\n        }\r\n        actions.splice(idx1, 1);\r\n        if(!actions.length) {\r\n            delete this.mappedInputIdToActions[inputId];\r\n        }\r\n        const idx = this.mappedActionToInputIds[action].indexOf(inputId);\r\n        if(idx < 0) throw new Error(`Index should be greater than -1`);\r\n        this.mappedActionToInputIds[action].splice(idx, 1);\r\n        if(!this.mappedActionToInputIds[action].length) {\r\n            delete this.mappedActionToInputIds[action];\r\n        }\r\n        this._onMappedActionRemovedListeners.forEach(l => l(eventData));\r\n        return eventData;\r\n    }\r\n\r\n    protected mapInputIdToAction(inputId: string, action: string) : AddInputIdActionMapEvent{\r\n        const eventData : AddInputIdActionMapEvent = { action, inputId };\r\n        const cur = this.mappedInputIdToActions[inputId];\r\n        if(cur?.includes(action)) return;\r\n        if(!this.mappedInputIdToActions[inputId]) {\r\n            this.mappedInputIdToActions[inputId] = [action];\r\n        } else {\r\n            this.mappedInputIdToActions[inputId].push(action);\r\n        }\r\n        if(!this.mappedActionToInputIds[action]) {\r\n            this.mappedActionToInputIds[action] = [inputId];\r\n        } else {\r\n            this.mappedActionToInputIds[action].push(inputId);\r\n        }\r\n        this._onMappedActionAddedListeners.forEach(l => l(eventData));\r\n        return eventData;\r\n    }\r\n    protected resolveActions(inputId: string) : Array<string> {\r\n        return this.mappedInputIdToActions[inputId];\r\n    }\r\n    protected resolveInputs(action: string) : Array<string> {\r\n        return this.mappedActionToInputIds[action];\r\n    }\r\n    public getDuplicateInputs() : MappedActionToInputState {\r\n        const dup = {};\r\n        Object.keys(this.mappedInputIdToActions).forEach(k => {\r\n            if(this.mappedActionToInputIds[k].length > 1) {\r\n                dup[k] =this.mappedActionToInputIds[k];\r\n            }\r\n        })\r\n        return dup;\r\n    }\r\n}","import { Angles, DirectionString } from \"./Core/types\";\r\n\r\nconst RADIAN_TO_DEGREE_MULTIPLIER = 180 / Math.PI;\r\nconst DEGREE_TO_RADIAN_MULTIPLIER = Math.PI / 180;\r\nexport function normalizeAxes(x: number, y: number) : { angles?: { default: Angles, north0: Angles }, power: number } {\r\n    if(Math.abs(x) <= .05 && Math.abs(y) <= .05) return { angles: null, power: 0 };\r\n    const radians = Math.atan2(y, x);\r\n    const degrees = radians*RADIAN_TO_DEGREE_MULTIPLIER;\r\n    let north0Degrees = 90 - degrees;\r\n    if(north0Degrees < 0) {\r\n        north0Degrees+=360;\r\n    }\r\n    return {\r\n        angles: {\r\n            default: {\r\n                radians,\r\n                degrees,\r\n            },\r\n            north0: {\r\n                degrees: north0Degrees,\r\n                radians: north0Degrees * DEGREE_TO_RADIAN_MULTIPLIER\r\n            },\r\n        },\r\n        power: Math.max(Math.abs(x) + Math.abs(y)),\r\n    }\r\n}\r\nexport function isValidDirection(direction: string) {\r\n    return ['north', 'northeast', 'east', 'southeast', 'south', 'southwest', 'west', 'northwest'].includes(direction);\r\n}\r\nexport function getDirectionFromNorth0Degrees(degrees) : DirectionString  {\r\n    const rounded = Math.round(degrees/45);\r\n    return rounded > 7 ? 'north' :\r\n        (<Array<DirectionString>>['north', 'northeast', 'east', 'southeast', 'south', 'southwest', 'west', 'northwest'])[rounded];\r\n}","import { GameInput as GottiGameInput } from './Core/GameInput';\r\nexport default GottiGameInput;","import { ControllerManager } from \"./Managers/ControllerManager\";\r\nimport { BaseControllerSystem } from \"./Systems/Controllers/BaseControllerSystem\";\r\nimport { InputSystem } from \"./Systems/InputSystem\";\r\nimport { MappedActionToInputState, UpdatedSystemActionState } from \"./types\";\r\nimport { KeyboardSystem } from \"./Systems/Controllers/KeyboardSystem\";\r\nimport { BaseTouchSystem } from \"./Systems/Touch/BaseTouchSystem\";\r\nimport { MouseSystem } from \"./Systems/Controllers/MouseSystem\";\r\n\r\nexport class GameInput {\r\n    private keyboardSystem: KeyboardSystem;\r\n    private mouseSystem: MouseSystem;\r\n    private controllerManager: ControllerManager;\r\n    private touchSystem: BaseTouchSystem;\r\n\r\n    public updateController: () => Array<UpdatedSystemActionState> = () => [];\r\n    public updateKeyboard: () => UpdatedSystemActionState = () => null;\r\n    public updateTouch: () => UpdatedSystemActionState = () => null;\r\n    public updateMouse: () => UpdatedSystemActionState = () => null;\r\n\r\n    private interfaceIsOpen : boolean;\r\n\r\n    constructor(mappedInputStates?: { keyboard?: MappedActionToInputState, mouse?: MappedActionToInputState, controller: any }, disableOpts?: { controller?: boolean, mouse?: boolean, keyboard?: boolean, touch?: boolean }) {\r\n        disableOpts = disableOpts || {};\r\n        !disableOpts.keyboard && this.initializeKeyboardSystem(mappedInputStates?.keyboard);\r\n        !disableOpts.mouse && this.initializeMouseManager();\r\n        !disableOpts.controller && this.initializeControllerManager(mappedInputStates.controller);\r\n     //   !disableOpts.touch && this.initializeTouchManager();\r\n    }\r\n    public update() : { keyboard: UpdatedSystemActionState, mouse: UpdatedSystemActionState, controller: Array<UpdatedSystemActionState>, touch: UpdatedSystemActionState } {\r\n        return {\r\n            keyboard: this.updateKeyboard(),\r\n            mouse: this.updateMouse(),\r\n            controller: this.updateController(),\r\n            touch: this.updateTouch(),\r\n        }\r\n    }\r\n    public updateOnlyMouse() {\r\n    }\r\n    public updateOnlyTouch() {\r\n    }\r\n    private registerSystemHandlers(system : InputSystem) {\r\n    }\r\n    private initializeKeyboardSystem(state?: MappedActionToInputState) {\r\n        this.keyboardSystem = new KeyboardSystem(state);\r\n        this.updateKeyboard = this.keyboardSystem.update.bind(this.keyboardSystem);\r\n    }\r\n    private initializeTouchManager(factory: () => BaseTouchSystem) {\r\n        this.touchSystem = factory();\r\n        //this.touchManager = new KeyboardManager();\r\n        this.updateTouch = this.touchSystem.update.bind(this.touchSystem);\r\n    }\r\n    private initializeMouseManager(state?: MappedActionToInputState) {\r\n        this.mouseSystem = new MouseSystem(state);\r\n        this.updateMouse = this.mouseSystem.update.bind(this.mouseSystem);\r\n    }\r\n    private initializeControllerManager(state?: any) {\r\n        this.controllerManager = new ControllerManager(state);\r\n        this.controllerManager.on('add', (system : BaseControllerSystem) => {\r\n            console.error('ADDED CONTROLLER SYSTEM:', system)\r\n        });\r\n        this.controllerManager.on('remove', (system : BaseControllerSystem) => {\r\n        });\r\n        this.controllerManager.init();\r\n        this.updateController = this.controllerManager.update.bind(this.controllerManager);\r\n    }\r\n}","import { BaseControllerSystem } from '../Systems/Controllers/BaseControllerSystem';\r\nimport { DefaultController } from '../Systems/Controllers/ControllerSystems';\r\nimport { BaseManager } from './BaseManager';\r\nimport { ActionState, ActionStateDatumChange } from '../types';\r\nexport class ControllerManager extends BaseManager {\r\n    readonly needsPolling: boolean = false;\r\n    readonly trackedSystemArray: Array<BaseControllerSystem> = [];\r\n    readonly initializedSystemArray: Array<BaseControllerSystem> = [];\r\n    private state: any;\r\n    constructor(state?: any) {\r\n        super();\r\n        this.state =state;\r\n        if(typeof navigator === 'undefined') throw new Error(`No navigator object found.`)\r\n        if(typeof window === 'undefined') throw new Error(`No window object found.`);\r\n        this.needsPolling = !('ongamepadconnected' in window);\r\n    }\r\n    public onClear() {\r\n        if(!this.needsPolling) {\r\n            window.removeEventListener(\"gamepadconnected\", this.handleGamePadConnected);\r\n            window.removeEventListener(\"gamepaddisconnected\", this.handleGamePadDisconnected);\r\n        }\r\n        [...this.initializedSystemArray].forEach(system => this.handleGamePadDisconnected({ gamepad: system.gamepad } as GamepadEvent));\r\n        if(this.initializedSystemArray.length) throw new Error(`Should have no initialized systems left.`)\r\n        if(!this.trackedSystemArray.every(s => !!s)) throw new Error(`Should have no truthy values in the tracked system array`)\r\n    }\r\n\r\n    public onUpdate() {\r\n        this.needsPolling && this.pollGamepads();\r\n    }\r\n\r\n    // seperate init function so we can listen to events on controller manager after construction before the native events get fired incase its synchronous\r\n    init() {\r\n        this.handleGamePadConnected = this.handleGamePadConnected.bind(this);\r\n        this.handleGamePadDisconnected = this.handleGamePadDisconnected.bind(this);\r\n        if(!this.needsPolling) {\r\n            // todo im going to query and init the arrays but im not sure if listening will do the callbacks right away and mess this up.\r\n            window.addEventListener(\"gamepadconnected\", this.handleGamePadConnected);\r\n            window.addEventListener(\"gamepaddisconnected\", this.handleGamePadDisconnected);\r\n        }\r\n        // even if we dont need to poll every tick, run the poll logic on init to get any already connected gamepads.\r\n        this.pollGamepads();\r\n    }\r\n\r\n    private handleGamePadConnected(e: GamepadEvent) {\r\n        const gpIdx = e.gamepad.index;\r\n        const gp : Gamepad = navigator.getGamepads()[gpIdx];\r\n        if(gp) {\r\n            if(this.trackedSystemArray[gpIdx]) {\r\n                console.error('gamepad:', gp, 'index:', e.gamepad.index)\r\n                throw new Error(`This gamepad already had an initialized system at the index`)\r\n            }\r\n            const system = this.controllerSystemFactory(gp);\r\n            this.trackedSystemArray[gpIdx] = system;\r\n            this.initializedSystemArray.push(system);\r\n            this.addSystem(system);\r\n        }\r\n    }\r\n    private handleGamePadDisconnected(e: GamepadEvent) {\r\n        const gpIdx = e.gamepad.index;\r\n        const gp : Gamepad = navigator.getGamepads()[gpIdx];\r\n        if(gp) {\r\n            const trackedSystem = this.trackedSystemArray[gpIdx];\r\n            if(!trackedSystem) throw new Error(`No tracked system found for index: ${gpIdx}`);\r\n            // set tracked system reference to null.\r\n            this.trackedSystemArray[gpIdx] = null;\r\n            const initIndex = this.initializedSystemArray.indexOf(trackedSystem);\r\n            if(initIndex < 0) throw new Error(`Expected init index to be greater than -1.`)\r\n            this.initializedSystemArray.splice(initIndex, 1);\r\n            this.removeSystem(trackedSystem);\r\n        }\r\n    }\r\n    private pollGamepads() {\r\n        const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator['webkitGetGamepads'] ? navigator['webkitGetGamepads'] : []);\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if(gamepad) {\r\n                const gamePadSystemInitialized  = this.initializedSystemArray[gamepad.index]\r\n                if(gamepad.connected) {\r\n                    if(!gamePadSystemInitialized) {\r\n                        this.handleGamePadConnected({ gamepad } as GamepadEvent)\r\n                    } else {\r\n                        gamePadSystemInitialized.gamepad = gamepad;\r\n                    }\r\n                } else if (!gamepad.connected && gamePadSystemInitialized) {\r\n                    this.handleGamePadDisconnected({ gamepad } as GamepadEvent)\r\n                }\r\n            } else {\r\n                //todo: figure out does the index here match the gamepad.index always? if so when will it become null vs connected = false?\r\n               // this.handleGamePadDisconnected({ gamepad: { index: i } } as GamepadEvent)\r\n            }\r\n        }\r\n    }\r\n    private controllerSystemFactory(g: Gamepad) : DefaultController {\r\n        const system = new DefaultController(g, this.state);\r\n        return system;\r\n    }\r\n}","export { DefaultController } from './DefaultController';\r\n","import { BaseControllerSystem } from '../BaseControllerSystem';\r\nimport { normalizeAxes, getDirectionFromNorth0Degrees } from '../../../../utils';\r\nexport class DefaultController extends BaseControllerSystem {\r\n    constructor(gamepad: Gamepad, state?: any) {\r\n        super(gamepad, state);\r\n        if(state) {\r\n            for(let action in state.default.sticks.left) {\r\n                this.mapStickToAction(0, { action, direction: state.default.sticks.left[action] }, false);\r\n            }\r\n        }\r\n    }\r\n    public updateState(): void {\r\n        super.updateState();\r\n        const updateStickState = (stickIndex, isPressed) => {\r\n            const movedMap = this.mappedStickActions.move[stickIndex];\r\n            const pressedMap = this.mappedStickActions.press[stickIndex];\r\n            if(movedMap) {\r\n                const stickX = parseFloat(this.gamepad.axes[stickIndex*2].toFixed(2));\r\n                const stickY = parseFloat((this.gamepad.axes[stickIndex*2+1]*-1).toFixed(2)) ;\r\n                const { angles, power } = normalizeAxes(stickX, stickY);\r\n                if(power) {\r\n                    const dir22 = getDirectionFromNorth0Degrees(angles.north0.degrees);\r\n                    console.log('dir was:', dir22, angles.north0.degrees)\r\n                    console.log('y was', this.gamepad.axes[stickIndex*2+1])\r\n                }\r\n\r\n                if(!power) {\r\n                    if(movedMap.degreeDirections) {\r\n                        movedMap.degreeDirections.forEach(d => {\r\n                            d.actions.forEach(a => {\r\n                                this.actionState[a] = false;\r\n                            });\r\n                        });\r\n                    }\r\n                    if(movedMap.stringDirections) {\r\n                        const keys = Object.keys(movedMap.stringDirections);\r\n                        keys.forEach(k => {\r\n                            movedMap.stringDirections[k].forEach(a => {\r\n                                this.actionState[a] = false\r\n                            })\r\n                        });\r\n                    }\r\n                    // make all false.\r\n                } else {\r\n                    const { degrees } = angles.north0;\r\n                    const dir = getDirectionFromNorth0Degrees(degrees);\r\n                    if(movedMap.stringDirections) {\r\n                        const keys = Object.keys(movedMap.stringDirections);\r\n                        keys.forEach(k => {\r\n                            movedMap.stringDirections[k].forEach(a => {\r\n                                this.actionState[a] = k === dir\r\n                            })\r\n                        });\r\n                    }\r\n                    if(movedMap.degreeDirections) {\r\n                        const matched = movedMap.degreeDirections.forEach(d => {\r\n                            d.actions.forEach(a => {\r\n                                this.actionState[a] = (!d.min || d.min <= degrees) && (!d.max || d.max >= degrees)\r\n                            });\r\n                        });\r\n                    }\r\n                    if(isPressed) {\r\n                        if(pressedMap.stringDirections) {\r\n                            const keys = Object.keys(pressedMap.stringDirections);\r\n                            keys.forEach(k => {\r\n                                pressedMap.stringDirections[k].forEach(a => {\r\n                                    this.actionState[a] = k === dir\r\n                                })\r\n                            });\r\n                        }\r\n                        if(pressedMap.degreeDirections) {\r\n                            const matched = pressedMap.degreeDirections.forEach(d => {\r\n                                d.actions.forEach(a => {\r\n                                    this.actionState[a] = (!d.min || d.min <= degrees) && (!d.max || d.max >= degrees)\r\n                                });\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        updateStickState(0, this.isStickPressed(0));\r\n        updateStickState(1, this.isStickPressed(1));\r\n    }\r\n}","import { InputSystem } from \"../InputSystem\";\r\nimport { StickAction, AddInputIdActionMapEvent, RemoveInputIdActionMapEvent, RangedStickAction, StickInputId } from \"../../types\";\r\nimport { isValidDirection } from \"../../../utils\";\r\n\r\ntype FormattedStickActionLookup = {\r\n    actions?: Array<string>,\r\n    stringDirections?: {\r\n        north?: Array<string>,\r\n        south?: Array<string>,\r\n        east?: Array<string>,\r\n        west?:Array<string>,\r\n        northwest?: Array<string>,\r\n        northeast?: Array<string>,\r\n        southwest?: Array<string>,\r\n        southeast?: Array<string>,\r\n    },\r\n    degreeDirections?: Array<{ min: number, max: number, actions: Array<string> }>\r\n}\r\n\r\nexport class BaseControllerSystem extends InputSystem {\r\n    public gamepad: Gamepad;\r\n    private buttonIndexIdMap: Array<string>;\r\n\r\n    private stickActionCount: {[action: string] : number } = {}\r\n\r\n    private _onMappedStickActionAddedListeners: Array<(event: StickAction) => void> = [];\r\n    private _onMappedStickActionRemovedListeners: Array<(event: StickAction) => void> = [];\r\n\r\n\r\n    readonly mappedStickRotationActions: {[stickIndex: number]: Array<{ start: number, end: number, callback: (rotation: number, power: number) => void }>} = {};\r\n    readonly mappedAxesActions: {[axesIndex: number]: Array<{ start: number, end: number, callback: (rotation: number) => void }>} = {};\r\n    readonly mappedStickActions: { press: Array<FormattedStickActionLookup>, move: Array<FormattedStickActionLookup> } = { press: [], move: [] };\r\n\r\n    constructor(gamepad: Gamepad, state: any) {\r\n        super();\r\n        this.gamepad = gamepad;\r\n    }\r\n    public onClear(): void {}\r\n    protected mapStickRangeToAction(axesIndex: number, start: number, end: number, callback: (StickEvent) => void) {\r\n        this.mappedStickRotationActions[axesIndex]\r\n    }\r\n    public isStickPressed(stickIndex: number) : boolean {\r\n        return false;\r\n    }\r\n    protected unmapInputFromAction(inputId: string, action: string) : RemoveInputIdActionMapEvent {\r\n        const actions = this.mappedInputIdToActions[inputId];\r\n        if(typeof actions === 'undefined') {\r\n            throw new Error(`The inputId ${inputId} was not mapped to any action.`)\r\n        }\r\n        const eventData : RemoveInputIdActionMapEvent = { inputId, action, actionNowUnmapped: false };\r\n        const idx1 = actions.indexOf(action);\r\n        if(idx1 < 0) {\r\n            throw new Error(`The inputId ${inputId} was not mapped to action ${action}.`)\r\n        }\r\n        actions.splice(idx1, 1);\r\n        if(!actions.length) {\r\n            delete this.mappedInputIdToActions[inputId];\r\n        }\r\n        const idx = this.mappedActionToInputIds[action].indexOf(inputId);\r\n        if(idx < 0) throw new Error(`Index should be greater than -1`);\r\n        this.mappedActionToInputIds[action].splice(idx, 1);\r\n        if(!this.mappedActionToInputIds[action].length) {\r\n            delete this.mappedActionToInputIds[action];\r\n        }\r\n        this._onMappedActionRemovedListeners.forEach(l => l(eventData));\r\n        return eventData;\r\n    }\r\n\r\n    public unmapStickFromAction(stickIndex: number, stickAction: StickAction, press: boolean) {\r\n        if(Array.isArray(stickAction)) {\r\n            stickAction.forEach(a => {\r\n                this.unmapStickFromAction(stickIndex, stickAction, press);\r\n            })\r\n            return;\r\n        }\r\n        const type = this.validateStickActionType(stickAction);\r\n        const stickActions = this.getStickActionLookup(stickIndex, press, false);\r\n        const inputId : StickInputId = { index: stickIndex };\r\n        const eventData : RemoveInputIdActionMapEvent = { inputId, actionNowUnmapped: false, action: '' };\r\n        let actionString;\r\n        if(type === 'string') {\r\n            actionString = stickAction;\r\n            const idx = stickActions.actions.indexOf(actionString);\r\n            if(idx < 0) throw new Error(`Expected`)\r\n            stickActions.actions.splice(idx, 1);\r\n            if(!stickActions.actions.length) {\r\n                delete stickActions.actions;\r\n            }\r\n            eventData.action = actionString;\r\n            this.updateStickActionCount(actionString, false)\r\n            eventData.actionNowUnmapped = !this.actionIsMapped(actionString);\r\n            this._onMappedActionRemovedListeners.forEach(l => l(eventData));\r\n        } else {\r\n            stickAction = (<RangedStickAction>stickAction)\r\n            actionString = stickAction.action;\r\n            const directions = Array.isArray(stickAction.direction) ? stickAction.direction : [stickAction.direction];\r\n            directions.forEach(direction => {\r\n                inputId.direction = direction;\r\n                if(typeof direction === 'string') {\r\n                    const idx = stickActions.stringDirections[direction].indexOf(actionString);\r\n                    if(idx < 0) throw new Error(`Action ${actionString} was not mapped to direction ${direction} on the ${stickIndex} stick`);\r\n                    stickActions.stringDirections[direction].splice(idx, 1);\r\n                    if(!stickActions.stringDirections[direction].length) {\r\n                        delete stickActions.stringDirections[direction];\r\n                        if(!(Object.keys(stickActions.stringDirections).length)) {\r\n                            delete stickActions.stringDirections;\r\n                        }\r\n                    }\r\n                } else {\r\n                    const { min, max } = direction;\r\n                    const found = stickActions.degreeDirections.find(d => d.min == min && d.max == d.max && d.actions.includes(actionString));\r\n                    if(!found) throw new Error(`Action ${actionString} was not mapped to direction min max: ${direction} on the ${stickIndex} stick`);\r\n                    found.actions.splice(found.actions.indexOf(actionString), 1);\r\n                    if(!found.actions.length) {\r\n                        stickActions.degreeDirections.splice(stickActions.degreeDirections.indexOf(found), 1);\r\n                        if(!stickActions.degreeDirections.length) {\r\n                            delete stickActions.degreeDirections;\r\n                        }\r\n                    }\r\n                }\r\n                this.updateStickActionCount(actionString, false)\r\n                eventData.action = actionString;\r\n                eventData.actionNowUnmapped = !this.actionIsMapped(actionString);\r\n                this._onMappedActionRemovedListeners.forEach(l => l(eventData));\r\n            })\r\n        }\r\n    }\r\n    private actionIsMapped(action: string) : boolean {\r\n        if(this.stickActionCount[action]) {\r\n            return true;\r\n        }\r\n        if(this.mappedActionToInputIds[action]?.length) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    private getStickActionLookup(stickIndex: number, isPress: boolean, createIfNotAdded=true) : FormattedStickActionLookup {\r\n        const key = isPress ? 'press' : 'move';\r\n        if(!this.mappedStickActions[key][stickIndex]) {\r\n            if(createIfNotAdded) {\r\n                this.mappedStickActions[key][stickIndex] = {};\r\n            } else {\r\n                throw new Error(`Expected to have index`)\r\n            }\r\n        }\r\n        return this.mappedStickActions[key][stickIndex];\r\n    }\r\n    private validateStickActionType(stickAction: StickAction) : 'string' | 'object' {\r\n        const type = typeof stickAction;\r\n        if(type !== 'string' && type !== 'object') {\r\n            throw new Error(`Invalid action type: ${stickAction}`)\r\n        }\r\n        return type\r\n    }\r\n\r\n    private updateStickActionCount(action: string, add: boolean) {\r\n        if(add) {\r\n            if(!this.stickActionCount[action]) {\r\n                this.stickActionCount[action] = 1;\r\n            } else {\r\n                this.stickActionCount[action]++;\r\n            }\r\n        } else {\r\n            this.stickActionCount[action]--;\r\n            if(!this.stickActionCount[action]) {\r\n                delete this.stickActionCount[action];\r\n            }\r\n        }\r\n    }\r\n\r\n    public mapStickToAction(stickIndex: number, stickAction: StickAction, press: boolean) {\r\n        console.error('mapping', stickIndex, stickAction);\r\n        if(Array.isArray(stickAction)) {\r\n            stickAction.forEach(a => {\r\n                this.mapStickToAction(stickIndex, stickAction, press);\r\n            })\r\n            return;\r\n        }\r\n        const type = this.validateStickActionType(stickAction);\r\n        const stickActions = this.getStickActionLookup(stickIndex, press, true);\r\n        const inputId : StickInputId = { index: stickIndex };\r\n        const eventData : AddInputIdActionMapEvent = { inputId, action: '' };\r\n        let actionString;\r\n        if(type === 'string') {\r\n            actionString = stickAction;\r\n            if(!stickActions.actions) {\r\n                stickActions.actions = [actionString];\r\n            } else {\r\n                stickActions.actions.push(actionString);\r\n            }\r\n            eventData.action = actionString;\r\n            this.updateStickActionCount(actionString, true)\r\n            this._onMappedActionAddedListeners.forEach(l => l(eventData));\r\n        } else {\r\n            stickAction = (<RangedStickAction>stickAction)\r\n            actionString = stickAction.action;\r\n            const directions = Array.isArray(stickAction.direction) ? stickAction.direction : [stickAction.direction];\r\n            directions.forEach(direction => {\r\n                inputId.direction = direction;\r\n                if(typeof direction === 'string') {\r\n                    if(!isValidDirection(direction)) {\r\n                        throw new Error(`Invalid direction string ${direction}`)\r\n                    }\r\n                    if(!stickActions.stringDirections) {\r\n                        stickActions.stringDirections = {[direction]: [actionString]}\r\n                    } else if (!stickActions.stringDirections[direction]) {\r\n                        stickActions.stringDirections[direction] = [actionString];\r\n                    } else {\r\n                        stickActions.stringDirections[direction].push(actionString);\r\n                    }\r\n                } else {\r\n                    const { min, max } = direction;\r\n                    this.validateMinMax(min, max)\r\n                    if(!stickActions.degreeDirections) {\r\n                        stickActions.degreeDirections = [{ min, max, actions: [actionString] }]\r\n                    } else {\r\n                        const found = stickActions.degreeDirections.find(d => d.min == min && d.max == max);\r\n                        if(found) {\r\n                            found.actions.push(actionString);\r\n                        }else {\r\n                            stickActions.degreeDirections.push({ min, max, actions: [actionString]});\r\n                            stickActions.degreeDirections.sort((aa, bb) => {\r\n                                const aaMin = aa.min || 0;\r\n                                const bbMin = bb.min || 0;\r\n                                return aaMin - bbMin;\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                this.updateStickActionCount(actionString, true)\r\n                eventData.action = actionString;\r\n                this._onMappedActionAddedListeners.forEach(l => l(eventData));\r\n            })\r\n        }\r\n    }\r\n\r\n    private makeButtonId(btnIndex: number) : string {\r\n        return `button_${btnIndex}`\r\n    }\r\n    public updateState(): void {\r\n        this.gamepad.buttons.forEach((b, i) => {\r\n            const resolvedBtnActions = super.resolveActions(this.makeButtonId(i));\r\n            resolvedBtnActions?.forEach(a => {\r\n                super.actionState[a] = b.pressed;\r\n            })\r\n        });\r\n    }\r\n    private validateMinMax(min?: number, max?: number) {\r\n        const hasMin =min !== undefined && min !== null;\r\n        const hasMax = max !== undefined && max !== null;\r\n\r\n        if(hasMin) {\r\n            if(min < 0 || min > 360) {\r\n                throw new Error(`Invalid degree value, must be 0-360`)\r\n            }\r\n        }\r\n        if(hasMax) {\r\n            if(max < 0 || max > 360) {\r\n                throw new Error(`Invalid degree value, must be 0-360`)\r\n            }\r\n        }\r\n        if(hasMax && hasMin) {\r\n            if(min >= max) {\r\n                throw new Error(`Min should be less than max.`)\r\n            }\r\n        }\r\n    }\r\n}","import { InputSystem } from \"../Systems/InputSystem\";\r\nimport { ActionState, ActionStateDatumChange } from \"../types\";\r\n\r\nexport abstract class BaseManager {\r\n    readonly managedSystems : Array<InputSystem> = [];\r\n    readonly _systemListeners: { 'add': Array<(system: InputSystem) => void>, 'remove' : Array<(system: InputSystem) => void> } = { add: [], remove: [] }\r\n    constructor() {\r\n    }\r\n    public update() : Array<{ state: ActionState, changed: {[action: string]: ActionStateDatumChange } }> {\r\n        this.onUpdate();\r\n        return this.managedSystems.map(s => s.update());\r\n    }\r\n    public clear() {\r\n        this.onClear();\r\n        const systems = [...this.managedSystems];\r\n        systems.forEach(this.removeSystem.bind(this));\r\n    }\r\n    public abstract onUpdate() : void;\r\n    public abstract onClear() : void;\r\n\r\n    public emit(eventname: 'remove' | 'add', system: InputSystem) {\r\n        if(eventname === 'add') {\r\n            this.managedSystems.push(system);\r\n        }\r\n        for(let i = 0; i < this._systemListeners[eventname].length; i++) {\r\n            this._systemListeners[eventname][i](system)\r\n        }\r\n    }\r\n    public addSystem(system: InputSystem) {\r\n        for(let i = 0; i < this._systemListeners['add'].length; i++) {\r\n            this._systemListeners['add'][i](system)\r\n        }\r\n        this.managedSystems.push(system);\r\n    }\r\n    public removeSystem(system: InputSystem) {\r\n        system.onClear();\r\n        for(let i = 0; i < this._systemListeners['remove'].length; i++) {\r\n            this._systemListeners['remove'][i](system)\r\n        }\r\n        const idx = this.managedSystems.indexOf(system);\r\n        idx > -1 && this.managedSystems.splice(idx, 1);\r\n    }\r\n    public on(eventname: 'remove' | 'add', cb: (system: InputSystem) => void) {\r\n        this._systemListeners[eventname].push(cb);\r\n    }\r\n    public off(eventname: 'remove' | 'add', cb: (system: InputSystem) => void) {\r\n        const idx = this._systemListeners[eventname].indexOf(cb);\r\n        idx > -1 && this._systemListeners[eventname].splice(idx, 1);\r\n    }\r\n}","import { InputSystem } from \"../InputSystem\";\r\nimport { MappedActionToInputState } from \"../../types\";\r\n\r\nexport class KeyboardSystem extends InputSystem {\r\n    private actionsFinished : Array<string> = [];\r\n    private actionsStarted : Array<string> = [];\r\n    constructor(state: MappedActionToInputState) {\r\n        super(state);\r\n        this.handleKeyDown = this.handleKeyDown.bind(this);\r\n        this.handleKeyUp = this.handleKeyUp.bind(this);\r\n        window.addEventListener('keydown', this.handleKeyDown)\r\n        window.addEventListener('keyup', this.handleKeyUp)\r\n    }\r\n    public updateState(): void {\r\n        this.actionsFinished.forEach(a => {\r\n            this.actionState[a] = false;\r\n        });\r\n        this.actionsStarted.forEach(a => {\r\n            this.actionState[a] = true;\r\n        })\r\n        this.actionsStarted.length = 0;\r\n        this.actionsFinished.length = 0;\r\n    }\r\n    private handleKeyDown(event: KeyboardEvent) {\r\n        const actions = this.resolveActions(event.code);\r\n        actions && this.actionsStarted.push(...actions);\r\n    }\r\n    private handleKeyUp(event: KeyboardEvent) {\r\n        const actions = this.resolveActions(event.code);\r\n        actions && this.actionsFinished.push(...actions);\r\n    }\r\n    public onClear(): void {\r\n        window.removeEventListener('keydown', this.handleKeyDown);\r\n        window.removeEventListener('keyup', this.handleKeyUp);\r\n    }\r\n}","import { InputSystem } from \"../InputSystem\";\r\nimport { MappedActionToInputState } from \"../../types\";\r\n\r\nexport class MouseSystem extends InputSystem {\r\n    private actionsFinished : Array<string> = [];\r\n    private actionsStarted : Array<string> = [];\r\n\r\n    constructor(state?: MappedActionToInputState) {\r\n        super(state);\r\n        this.handleMouseDown = this.handleMouseDown.bind(this);\r\n        this.handleMouseUp = this.handleMouseUp.bind(this);\r\n        this.handleMouseMove = this.handleMouseMove.bind(this);\r\n\r\n        window.addEventListener('mousedown', this.handleMouseDown);\r\n        window.addEventListener('mouseup', this.handleMouseUp);\r\n        window.addEventListener('mousemove', this.handleMouseMove);\r\n    }\r\n    public updateState(): void {\r\n        this.actionsFinished.forEach(a => {\r\n            this.actionState[a] = false;\r\n        });\r\n        this.actionsStarted.forEach(a => {\r\n            this.actionState[a] = true;\r\n        })\r\n        this.actionsStarted.length = 0;\r\n        this.actionsFinished.length = 0;\r\n    }\r\n    private handleMouseMove(event: MouseEvent) {\r\n    }\r\n    private handleMouseDown(event: MouseEvent) {\r\n        const actions = this.resolveActions(`${event.button}`);\r\n        actions &&  this.actionsStarted.push(...actions);\r\n    }\r\n    private handleMouseUp(event: MouseEvent) {\r\n        const actions = this.resolveActions(`${event.button}`);\r\n        actions && this.actionsFinished.push(...actions);\r\n    }\r\n    public onClear(): void {\r\n        window.removeEventListener('mousedown', this.handleMouseDown);\r\n        window.removeEventListener('mouseup', this.handleMouseUp);\r\n        window.removeEventListener('mousemove', this.handleMouseMove);\r\n    }\r\n}"],"sourceRoot":""}