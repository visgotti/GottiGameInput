{"version":3,"sources":["webpack://GottiGameInput/webpack/universalModuleDefinition","webpack://GottiGameInput/webpack/bootstrap","webpack://GottiGameInput/./src/Core/Systems/InputSystem.ts","webpack://GottiGameInput/./src/utils.ts","webpack://GottiGameInput/./src/index.ts","webpack://GottiGameInput/./src/Core/GameInput.ts","webpack://GottiGameInput/./src/Core/Managers/ControllerManager.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/ControllerSystems/index.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/ControllerSystems/DefaultController.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/BaseControllerSystem.ts","webpack://GottiGameInput/./src/Core/Managers/BaseManager.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/KeyboardSystem.ts","webpack://GottiGameInput/./src/Core/Systems/Controllers/MouseSystem.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","mappedActionToInputIds","_onActionListeners","_onMappedActionAddedListeners","_onMappedActionRemovedListeners","actionState","actionNames","mappedInputIdToActions","this","applyActionToInputMap","validateActionToInputMap","Error","action","addActionState","forEach","input","mapInputIdToAction","prevState","updateState","changed","length","curAction","previous","current","power","angles","default","degrees","changeObj","state","filter","actionName","keys","cb","push","listeners","idx","indexOf","splice","inputId","Array","isArray","unmapInputFromAction","actions","eventData","actionNowUnmapped","idx1","a","cur","includes","dup","k","RADIAN_TO_DEGREE_MULTIPLIER","Math","PI","DEGREE_TO_RADIAN_MULTIPLIER","x","y","abs","radians","atan2","north0Degrees","north0","max","direction","rounded","round","mappedInputStates","disableOpts","updateController","updateKeyboard","updateTouch","updateMouse","keyboard","initializeKeyboardSystem","mouse","initializeMouseManager","controller","initializeControllerManager","touch","system","keyboardSystem","KeyboardSystem","update","touchSystem","mouseSystem","MouseSystem","controllerManager","ControllerManager","on","console","error","init","BaseManager","super","needsPolling","trackedSystemArray","initializedSystemArray","navigator","removeEventListener","handleGamePadConnected","handleGamePadDisconnected","gamepad","every","pollGamepads","addEventListener","e","gpIdx","index","gp","getGamepads","controllerSystemFactory","addSystem","trackedSystem","initIndex","removeSystem","gamepads","gamePadSystemInitialized","connected","g","DefaultController","BaseControllerSystem","applyControllerState","triggers","l1","l2","r1","r2","apply","trigger","btnIdx","isPower","sticks","left","leftPress","right","rightPress","applyStick","stick","isPressed","mapStickToAction","dpad","applyControllerDPad","north","west","east","south","buttonIndex","buttons","applyControllerSticks","applyControllerTriggers","applyControllerButtons","select","start","stickIndex","pressed","stickActionCount","updateStickState","movedMap","mappedStickActions","move","pressedMap","press","stickX","parseFloat","axes","toFixed","stickY","normalizeAxes","dir","getDirectionFromNorth0Degrees","degreeDirections","wasTrueLookup","stringDirections","isStickPressed","InputSystem","_onMappedStickActionAddedListeners","_onMappedStickActionRemovedListeners","mappedStickRotationActions","mappedAxesActions","trackedStickActions","axesIndex","end","callback","stickAction","unmapStickFromAction","type","validateStickActionType","stickActions","getStickActionLookup","actionString","updateStickActionCount","actionIsMapped","min","found","find","isPress","createIfNotAdded","add","isValidDirection","validateMinMax","sort","aa","bb","b","resolvedBtnActions","resolveActions","log","isPowerBtn","hasMin","hasMax","stickMap","wasValid","managedSystems","_systemListeners","remove","onUpdate","map","onClear","eventname","actionsFinished","actionsStarted","handleKeyDown","handleKeyUp","event","code","handleMouseDown","handleMouseUp","handleMouseMove","button"],"mappings":"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","file":"gotti-game-input.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"GottiGameInput\"] = factory();\n\telse\n\t\troot[\"GottiGameInput\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { ActionStateDatumChange, AddInputIdActionMapEvent, RemoveInputIdActionMapEvent, MappedActionToInputState, UpdatedSystemActionState, StickAngleState, MappedInputToActionStates } from \"../types\";\r\n\r\ntype ActionState = {[actionName: string]: boolean | number }\r\n\r\n// type: 'controller' | 'mouse' | 'keyboard' | 'touch'\r\n\r\nexport abstract class InputSystem {\r\n    private _onActionListeners: {[actionName: string]: Array<(event: ActionStateDatumChange) => void>} = {}\r\n    protected _onMappedActionAddedListeners: Array<(event: AddInputIdActionMapEvent) => void> = [];\r\n    protected _onMappedActionRemovedListeners: Array<(event: RemoveInputIdActionMapEvent) => void> = [];\r\n\r\n    readonly actionState: {[actionName: string]: boolean | number | string | StickAngleState } = {};\r\n    private actionNames: Array<string> = [];\r\n\r\n    protected mappedInputIdToActions: MappedInputToActionStates = {};\r\n    protected mappedActionToInputIds: MappedActionToInputState = {};\r\n  //   protected mappedActionToOrderedInputCombos : {[action: string]: Array<string>}\r\n  //  protected mappedActionToUnorderedInputCombos : {[action: string]: Array<string>}\r\n    // protected inputToActionCombos : {[inputId: string]: Array<actionCombo> }\r\n\r\n    constructor(mappedActionToInputIds?: MappedActionToInputState) {\r\n        mappedActionToInputIds && this.applyActionToInputMap(mappedActionToInputIds);\r\n    }\r\n    protected applyActionToInputMap(mappedActionToInputIds: {[action: string]: Array<string | number> }) {\r\n        if(!this.validateActionToInputMap(mappedActionToInputIds)) throw new Error(`Invalid.`);\r\n        for(let action in mappedActionToInputIds) {\r\n            this.addActionState(action, false);\r\n            mappedActionToInputIds[action].forEach(input => {\r\n                this.mapInputIdToAction(input, action);\r\n            });\r\n        }\r\n    }\r\n    public getMappedActionInputs() : MappedActionToInputState {\r\n        return { ...this.mappedActionToInputIds };\r\n    }\r\n    private validateActionToInputMap(mappedActionToInputIds: {[action: string]: Array<string | number> }) : boolean {\r\n        //todo:... make sure nothing gets removed when it shouldnt.\r\n        return true;\r\n    }\r\n    public abstract onClear() : void;\r\n    public abstract updateState() : void;\r\n\r\n    public update() : UpdatedSystemActionState {\r\n        const prevState = { ...this.actionState };\r\n        this.updateState();\r\n        let changed : {[action:string]: ActionStateDatumChange }  = null;\r\n        for(let i = 0; i < this.actionNames.length; i++) {\r\n            const curAction = this.actionNames[i];\r\n            const previous = prevState[curAction];\r\n            const current = this.actionState[curAction]\r\n            if(\r\n                (typeof current !== 'object' && previous !== current) ||\r\n                // @ts-ignore\r\n                (current.power !== previous?.power || current.angles?.default.degrees !== previous.angles?.default.degrees)) {\r\n                changed = changed || {};\r\n                const changeObj = { previous, current };\r\n                changed[curAction] = changeObj ;\r\n                this._onActionListeners[curAction]?.forEach(l => l(changeObj));\r\n            }\r\n        }\r\n        // @ts-ignore\r\n        return { state: this.actionState, changed };\r\n    }\r\n\r\n    public getUnmappedActions() : Array<string> {\r\n        return this.actionNames.filter(n => {\r\n            return !(n in this.mappedActionToInputIds);\r\n        })\r\n    }\r\n\r\n    protected handleActionChange(actionName: string, value: boolean) {\r\n        if(!(actionName in this.actionState)) throw new Error(`Invalid action changed ${actionName}`)\r\n    }\r\n    public addActionState(action: string, value=false) {\r\n        if(action in this.actionState) throw new Error(`Already added action ${action}`);\r\n        this.actionState[action] = value;\r\n        this.actionNames = Object.keys(this.actionState);\r\n    }\r\n    public removeActionState(action: string) {\r\n        if(!(action in this.actionState)) throw new Error(`No action added: ${action}`);\r\n        delete this.actionState[action];\r\n        this.actionNames = Object.keys(this.actionState);\r\n    }\r\n    public onActionChange(actionName: string, cb: (event: ActionStateDatumChange) => void) {\r\n        if(this._onActionListeners[actionName]) {\r\n            this._onActionListeners[actionName].push(cb);\r\n        } else {\r\n            this._onActionListeners[actionName] = [cb]\r\n        }\r\n    }\r\n    public offActionChange(actionName: string, cb: (event: ActionStateDatumChange) => void) {\r\n        const listeners = this._onActionListeners[actionName];\r\n        if(listeners) {\r\n            const idx = listeners.indexOf(cb)\r\n            idx > -1 && listeners.splice(idx, 1);\r\n            if(!listeners.length) {\r\n                delete this._onActionListeners[actionName];\r\n            }\r\n        }\r\n    }\r\n    public onMappedActionAdded(cb: (event: AddInputIdActionMapEvent) => void) : number {\r\n        return this._onMappedActionAddedListeners.push(cb);\r\n    }\r\n    public offMappedActionAdded(cb: (payload: AddInputIdActionMapEvent) => void) : number {\r\n        const idx = this._onMappedActionAddedListeners.push(cb);\r\n        idx > -1 && this._onMappedActionAddedListeners.splice(idx, 1);\r\n        return this._onMappedActionAddedListeners.length;\r\n    }\r\n    public onMappedActionRemoved(cb: (event: RemoveInputIdActionMapEvent) => void) : number {\r\n        return this._onMappedActionRemovedListeners.push(cb);\r\n    }\r\n    public offMappedActionRemoved(cb: (payload: RemoveInputIdActionMapEvent) => void) : number {\r\n        const idx = this._onMappedActionRemovedListeners.indexOf(cb)\r\n        idx > -1 && this._onMappedActionRemovedListeners.splice(idx, 1);\r\n        return this._onMappedActionRemovedListeners.length;\r\n    }\r\n\r\n    protected unmapInputFromAction(inputId: string | Array<string>, action: string) : RemoveInputIdActionMapEvent {\r\n        if(Array.isArray(inputId)) {\r\n            inputId.forEach(i => {\r\n                this.unmapInputFromAction(i, action);\r\n            });\r\n            return;\r\n        }\r\n        const actions = this.mappedInputIdToActions[inputId];\r\n        if(typeof actions === 'undefined') {\r\n            throw new Error(`The inputId ${inputId} was not mapped to any action.`)\r\n        }\r\n        const eventData : RemoveInputIdActionMapEvent = { inputId, action, actionNowUnmapped: false };\r\n        const idx1 = actions.indexOf(action);\r\n        if(idx1 < 0) {\r\n            throw new Error(`The inputId ${inputId} was not mapped to action ${action}.`)\r\n        }\r\n        actions.splice(idx1, 1);\r\n        if(!actions.length) {\r\n            delete this.mappedInputIdToActions[inputId];\r\n        }\r\n        const idx = this.mappedActionToInputIds[action].indexOf(inputId);\r\n        if(idx < 0) throw new Error(`Index should be greater than -1`);\r\n        this.mappedActionToInputIds[action].splice(idx, 1);\r\n        if(!this.mappedActionToInputIds[action].length) {\r\n            delete this.mappedActionToInputIds[action];\r\n        }\r\n        this._onMappedActionRemovedListeners.forEach(l => l(eventData));\r\n        return eventData;\r\n    }\r\n\r\n    protected mapInputIdToAction(inputId: string | number | Array<string | number>, action: string | Array<string>) : AddInputIdActionMapEvent{\r\n        if(Array.isArray(inputId)) {\r\n            inputId.forEach(i => {\r\n                this.mapInputIdToAction(i, action);\r\n            });\r\n            return;\r\n        }\r\n        if(Array.isArray(action)) {\r\n            action.forEach(a => {\r\n                this.mapInputIdToAction(inputId, a);\r\n            });\r\n        }\r\n        this.actionState[action as string] = false;\r\n        const eventData : AddInputIdActionMapEvent = { action: action as string, inputId };\r\n        const cur = this.mappedInputIdToActions[inputId];\r\n        if(cur?.includes(action as string)) return;\r\n        if(!this.mappedInputIdToActions[inputId]) {\r\n            this.mappedInputIdToActions[inputId] = [action as string];\r\n        } else {\r\n            this.mappedInputIdToActions[inputId].push(action as string);\r\n        }\r\n        if(!this.mappedActionToInputIds[action as string]) {\r\n            this.mappedActionToInputIds[action as string] = [inputId];\r\n        } else {\r\n            this.mappedActionToInputIds[action as string].push(inputId);\r\n        }\r\n        this._onMappedActionAddedListeners.forEach(l => l(eventData));\r\n        return eventData;\r\n    }\r\n    protected resolveActions(inputId: string | number) : Array<string> {\r\n        return this.mappedInputIdToActions[inputId];\r\n    }\r\n    protected resolveInputs(action: string) : Array<string | number> {\r\n        return this.mappedActionToInputIds[action];\r\n    }\r\n    public getDuplicateInputs() : MappedActionToInputState {\r\n        const dup = {};\r\n        Object.keys(this.mappedInputIdToActions).forEach(k => {\r\n            if(this.mappedActionToInputIds[k].length > 1) {\r\n                dup[k] =this.mappedActionToInputIds[k];\r\n            }\r\n        })\r\n        return dup;\r\n    }\r\n}","import { Angles, DirectionString } from \"./Core/types\";\r\n\r\nconst RADIAN_TO_DEGREE_MULTIPLIER = 180 / Math.PI;\r\nconst DEGREE_TO_RADIAN_MULTIPLIER = Math.PI / 180;\r\nexport function normalizeAxes(x: number, y: number) : { angles?: { default: Angles, north0: Angles }, power: number } {\r\n    if(Math.abs(x) <= .05 && Math.abs(y) <= .05) return { angles: null, power: 0 };\r\n    const radians = Math.atan2(y, x);\r\n    const degrees = radians*RADIAN_TO_DEGREE_MULTIPLIER;\r\n    let north0Degrees = 90 - degrees;\r\n    if(north0Degrees < 0) {\r\n        north0Degrees+=360;\r\n    }\r\n    return {\r\n        angles: {\r\n            default: {\r\n                radians,\r\n                degrees,\r\n            },\r\n            north0: {\r\n                degrees: north0Degrees,\r\n                radians: north0Degrees * DEGREE_TO_RADIAN_MULTIPLIER\r\n            },\r\n        },\r\n        power: Math.max(Math.abs(x) + Math.abs(y)),\r\n    }\r\n}\r\nexport function isValidDirection(direction: string) {\r\n    return ['north', 'northeast', 'east', 'southeast', 'south', 'southwest', 'west', 'northwest'].includes(direction);\r\n}\r\nexport function getDirectionFromNorth0Degrees(degrees) : DirectionString  {\r\n    const rounded = Math.round(degrees/45);\r\n    return rounded > 7 ? 'north' :\r\n        (<Array<DirectionString>>['north', 'northeast', 'east', 'southeast', 'south', 'southwest', 'west', 'northwest'])[rounded];\r\n}","import { GameInput as GottiGameInput } from './Core/GameInput';\r\nexport default GottiGameInput;","import { ControllerManager } from \"./Managers/ControllerManager\";\r\nimport { BaseControllerSystem } from \"./Systems/Controllers/BaseControllerSystem\";\r\nimport { InputSystem } from \"./Systems/InputSystem\";\r\nimport { MappedActionToInputState, UpdatedSystemActionState } from \"./types\";\r\nimport { KeyboardSystem } from \"./Systems/Controllers/KeyboardSystem\";\r\nimport { BaseTouchSystem } from \"./Systems/Touch/BaseTouchSystem\";\r\nimport { MouseSystem } from \"./Systems/Controllers/MouseSystem\";\r\n\r\nexport class GameInput {\r\n    private keyboardSystem: KeyboardSystem;\r\n    private mouseSystem: MouseSystem;\r\n    private controllerManager: ControllerManager;\r\n    private touchSystem: BaseTouchSystem;\r\n\r\n    public updateController: () => Array<UpdatedSystemActionState> = () => [];\r\n    public updateKeyboard: () => UpdatedSystemActionState = () => null;\r\n    public updateTouch: () => UpdatedSystemActionState = () => null;\r\n    public updateMouse: () => UpdatedSystemActionState = () => null;\r\n\r\n    private interfaceIsOpen : boolean;\r\n\r\n    constructor(mappedInputStates?: { keyboard?: MappedActionToInputState, mouse?: MappedActionToInputState, controller: any }, disableOpts?: { controller?: boolean, mouse?: boolean, keyboard?: boolean, touch?: boolean }) {\r\n        disableOpts = disableOpts || {};\r\n        !disableOpts.keyboard && this.initializeKeyboardSystem(mappedInputStates?.keyboard);\r\n        !disableOpts.mouse && this.initializeMouseManager();\r\n        !disableOpts.controller && this.initializeControllerManager(mappedInputStates.controller);\r\n     //   !disableOpts.touch && this.initializeTouchManager();\r\n    }\r\n    public update() : { keyboard: UpdatedSystemActionState, mouse: UpdatedSystemActionState, controller: Array<UpdatedSystemActionState>, touch: UpdatedSystemActionState } {\r\n        return {\r\n            keyboard: this.updateKeyboard(),\r\n            mouse: this.updateMouse(),\r\n            controller: this.updateController(),\r\n            touch: this.updateTouch(),\r\n        }\r\n    }\r\n    public updateOnlyMouse() {\r\n    }\r\n    public updateOnlyTouch() {\r\n    }\r\n    private registerSystemHandlers(system : InputSystem) {\r\n    }\r\n    private initializeKeyboardSystem(state?: MappedActionToInputState) {\r\n        this.keyboardSystem = new KeyboardSystem(state);\r\n        this.updateKeyboard = this.keyboardSystem.update.bind(this.keyboardSystem);\r\n    }\r\n    private initializeTouchManager(factory: () => BaseTouchSystem) {\r\n        this.touchSystem = factory();\r\n        //this.touchManager = new KeyboardManager();\r\n        this.updateTouch = this.touchSystem.update.bind(this.touchSystem);\r\n    }\r\n    private initializeMouseManager(state?: MappedActionToInputState) {\r\n        this.mouseSystem = new MouseSystem(state);\r\n        this.updateMouse = this.mouseSystem.update.bind(this.mouseSystem);\r\n    }\r\n    private initializeControllerManager(state?: any) {\r\n        this.controllerManager = new ControllerManager(state);\r\n        this.controllerManager.on('add', (system : BaseControllerSystem) => {\r\n            console.error('ADDED CONTROLLER SYSTEM:', system)\r\n        });\r\n        this.controllerManager.on('remove', (system : BaseControllerSystem) => {\r\n        });\r\n        this.controllerManager.init();\r\n        this.updateController = this.controllerManager.update.bind(this.controllerManager);\r\n    }\r\n}","import { BaseControllerSystem } from '../Systems/Controllers/BaseControllerSystem';\r\nimport { DefaultController } from '../Systems/Controllers/ControllerSystems';\r\nimport { BaseManager } from './BaseManager';\r\nimport { ActionState, ActionStateDatumChange } from '../types';\r\nexport class ControllerManager extends BaseManager {\r\n    readonly needsPolling: boolean = false;\r\n    readonly trackedSystemArray: Array<BaseControllerSystem> = [];\r\n    readonly initializedSystemArray: Array<BaseControllerSystem> = [];\r\n    private state: any;\r\n    constructor(state?: any) {\r\n        super();\r\n        this.state =state;\r\n        if(typeof navigator === 'undefined') throw new Error(`No navigator object found.`)\r\n        if(typeof window === 'undefined') throw new Error(`No window object found.`);\r\n        this.needsPolling = !('ongamepadconnected' in window);\r\n    }\r\n    public onClear() {\r\n        if(!this.needsPolling) {\r\n            window.removeEventListener(\"gamepadconnected\", this.handleGamePadConnected);\r\n            window.removeEventListener(\"gamepaddisconnected\", this.handleGamePadDisconnected);\r\n        }\r\n        [...this.initializedSystemArray].forEach(system => this.handleGamePadDisconnected({ gamepad: system.gamepad } as GamepadEvent));\r\n        if(this.initializedSystemArray.length) throw new Error(`Should have no initialized systems left.`)\r\n        if(!this.trackedSystemArray.every(s => !!s)) throw new Error(`Should have no truthy values in the tracked system array`)\r\n    }\r\n\r\n    public onUpdate() {\r\n        this.needsPolling && this.pollGamepads();\r\n    }\r\n\r\n    // seperate init function so we can listen to events on controller manager after construction before the native events get fired incase its synchronous\r\n    init() {\r\n        this.handleGamePadConnected = this.handleGamePadConnected.bind(this);\r\n        this.handleGamePadDisconnected = this.handleGamePadDisconnected.bind(this);\r\n        if(!this.needsPolling) {\r\n            // todo im going to query and init the arrays but im not sure if listening will do the callbacks right away and mess this up.\r\n            window.addEventListener(\"gamepadconnected\", this.handleGamePadConnected);\r\n            window.addEventListener(\"gamepaddisconnected\", this.handleGamePadDisconnected);\r\n        }\r\n        // even if we dont need to poll every tick, run the poll logic on init to get any already connected gamepads.\r\n        this.pollGamepads();\r\n    }\r\n\r\n    private handleGamePadConnected(e: GamepadEvent) {\r\n        const gpIdx = e.gamepad.index;\r\n        const gp : Gamepad = navigator.getGamepads()[gpIdx];\r\n        if(gp) {\r\n            if(this.trackedSystemArray[gpIdx]) {\r\n                console.error('gamepad:', gp, 'index:', e.gamepad.index)\r\n                throw new Error(`This gamepad already had an initialized system at the index`)\r\n            }\r\n            const system = this.controllerSystemFactory(gp);\r\n            this.trackedSystemArray[gpIdx] = system;\r\n            this.initializedSystemArray.push(system);\r\n            this.addSystem(system);\r\n        }\r\n    }\r\n    private handleGamePadDisconnected(e: GamepadEvent) {\r\n        const gpIdx = e.gamepad.index;\r\n        const gp : Gamepad = navigator.getGamepads()[gpIdx];\r\n        if(gp) {\r\n            const trackedSystem = this.trackedSystemArray[gpIdx];\r\n            if(!trackedSystem) throw new Error(`No tracked system found for index: ${gpIdx}`);\r\n            // set tracked system reference to null.\r\n            this.trackedSystemArray[gpIdx] = null;\r\n            const initIndex = this.initializedSystemArray.indexOf(trackedSystem);\r\n            if(initIndex < 0) throw new Error(`Expected init index to be greater than -1.`)\r\n            this.initializedSystemArray.splice(initIndex, 1);\r\n            this.removeSystem(trackedSystem);\r\n        }\r\n    }\r\n    private pollGamepads() {\r\n        const gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator['webkitGetGamepads'] ? navigator['webkitGetGamepads'] : []);\r\n        for (let i = 0; i < gamepads.length; i++) {\r\n            const gamepad = gamepads[i];\r\n            if(gamepad) {\r\n                const gamePadSystemInitialized  = this.initializedSystemArray[gamepad.index]\r\n                if(gamepad.connected) {\r\n                    if(!gamePadSystemInitialized) {\r\n                        this.handleGamePadConnected({ gamepad } as GamepadEvent)\r\n                    } else {\r\n                        gamePadSystemInitialized.gamepad = gamepad;\r\n                    }\r\n                } else if (!gamepad.connected && gamePadSystemInitialized) {\r\n                    this.handleGamePadDisconnected({ gamepad } as GamepadEvent)\r\n                }\r\n            } else {\r\n                //todo: figure out does the index here match the gamepad.index always? if so when will it become null vs connected = false?\r\n               // this.handleGamePadDisconnected({ gamepad: { index: i } } as GamepadEvent)\r\n            }\r\n        }\r\n    }\r\n    private controllerSystemFactory(g: Gamepad) : DefaultController {\r\n        const system = new DefaultController(g, this.state.default);\r\n        return system;\r\n    }\r\n}","export { DefaultController } from './DefaultController';\r\n","import { BaseControllerSystem } from '../BaseControllerSystem';\r\nimport { normalizeAxes, getDirectionFromNorth0Degrees } from '../../../../utils';\r\nimport { DefaultControllerState, DefaultControllerStickState, DirectionalActionObject, DefaultTriggerState, DefaultControllerButtonState } from '../../../types';\r\nexport class DefaultController extends BaseControllerSystem {\r\n    constructor(gamepad: Gamepad, state?: DefaultControllerState) {\r\n        super(gamepad, state);\r\n        if(state) {\r\n            this.applyControllerState(state);\r\n        }\r\n    }\r\n\r\n    protected applyControllerTriggers(triggers: DefaultTriggerState) {\r\n        const { l1, l2, r1, r2 } = triggers;\r\n        const apply = (trigger, btnIdx, isPower: boolean) => {\r\n            if (Array.isArray(trigger)) {\r\n                trigger.forEach(a => {\r\n                    this.mapInputIdToAction( (btnIdx), a);\r\n                    if(isPower) {\r\n                        this.actionState[a] = 0;\r\n                    } else {\r\n                        this.actionState[a] = false;\r\n                    }\r\n                })\r\n            } else {\r\n                this.mapInputIdToAction(btnIdx, trigger);\r\n                if(isPower) {\r\n                    this.actionState[trigger] = 0;\r\n                } else {\r\n                    this.actionState[trigger] = false;\r\n                }\r\n            }\r\n        }\r\n        l1 && apply(l1, 4, false);\r\n        l2 && apply(l2, 6, true);\r\n        r1 && apply(r1, 5, false);\r\n        r2 && apply(r2, 7, true);\r\n    }\r\n\r\n    protected applyControllerSticks(sticks: DefaultControllerStickState) {\r\n        const { left, leftPress, right, rightPress } = sticks;\r\n        const applyStick = (stick, index, isPressed) => {\r\n            if (Array.isArray(stick) || typeof stick === 'string') {\r\n                this.mapStickToAction(index, stick, isPressed);\r\n            } else if (typeof stick === 'object') {\r\n                for (let action in stick) {\r\n                    this.mapStickToAction(index, {action, direction: stick[action]}, isPressed);\r\n                }\r\n            } else {\r\n                throw new Error(`unhandled left controller state`)\r\n            }\r\n        }\r\n        left && applyStick(left, 0, false);\r\n        leftPress && applyStick(leftPress, 0,true);\r\n        right && applyStick(right, 1, false);\r\n        rightPress && applyStick(rightPress, 1, true);\r\n    }\r\n    public applyControllerDPad(dpad: DirectionalActionObject | Array<DirectionalActionObject>) {\r\n        if(Array.isArray(dpad)) {\r\n            dpad.forEach(d => this.applyControllerDPad);\r\n        } else {\r\n            const actionMap = {};\r\n            const { north, west, east, south } = dpad;\r\n            north && this.mapInputIdToAction(12, north);\r\n            south && this.mapInputIdToAction(13, south);\r\n            west && this.mapInputIdToAction(14, west);\r\n            east && this.mapInputIdToAction(15, east);\r\n        }\r\n    }\r\n    public isPowerBtn(buttonIndex: number) {\r\n        return buttonIndex === 6 || buttonIndex === 7\r\n    }\r\n    public applyControllerState(state: DefaultControllerState) {\r\n        const { sticks, triggers, dpad, buttons } = state;\r\n        sticks && this.applyControllerSticks(sticks);\r\n        dpad && this.applyControllerDPad(dpad);\r\n        triggers && this.applyControllerTriggers(triggers);\r\n        buttons && this.applyControllerButtons(buttons);\r\n    }\r\n    public applyControllerButtons(buttons: DefaultControllerButtonState) {\r\n        const { select, start, north, south, east, west } = buttons;\r\n        const mapBtn = (action, idx: number) => {\r\n            const btnId =  (idx);\r\n            this.mapInputIdToAction(btnId, action);\r\n        }\r\n        select && this.mapInputIdToAction(8, select);\r\n        start && this.mapInputIdToAction(9, start);\r\n        north && this.mapInputIdToAction(3, north);\r\n        west && this.mapInputIdToAction(2, west);\r\n        east && this.mapInputIdToAction(1, east);\r\n        south && this.mapInputIdToAction(0, south);\r\n    }\r\n\r\n    public isStickPressed(stickIndex: number): boolean {\r\n        // default controller stick index buttons are 10 and 11\r\n        return this.gamepad.buttons[stickIndex+10].pressed;\r\n    }\r\n    public updateState(): void {\r\n        super.updateState();\r\n        Object.keys(this.stickActionCount).forEach(k => {\r\n            this.actionState[k] = false;\r\n        });\r\n        const updateStickState = (stickIndex, isPressed) => {\r\n            const movedMap = this.mappedStickActions.move[stickIndex];\r\n            const pressedMap = this.mappedStickActions.press[stickIndex];\r\n            if(movedMap || pressedMap) {\r\n                const stickX = parseFloat(this.gamepad.axes[stickIndex*2].toFixed(2));\r\n                const stickY = parseFloat((this.gamepad.axes[stickIndex*2+1]).toFixed(2))*-1 ;\r\n                const { angles, power } = normalizeAxes(stickX, stickY);\r\n                if(!power) {\r\n                    if(movedMap) {\r\n                        movedMap.degreeDirections?.forEach(d => {\r\n                            d.actions.forEach(a => {\r\n                                if(!this.wasTrueLookup[a]) {\r\n                                    this.actionState[a] = false;\r\n                                }\r\n                            });\r\n                        });\r\n                        if(movedMap.stringDirections) {\r\n                            const keys = Object.keys(movedMap.stringDirections);\r\n                            keys.forEach(k => {\r\n                                movedMap.stringDirections[k].forEach(a => {\r\n                                    if(!this.wasTrueLookup[a]) {\r\n                                        this.actionState[a] = false;\r\n                                    }\r\n                                })\r\n                            });\r\n                        }\r\n                        movedMap.actions?.forEach(a => {\r\n                            this.actionState[a] = { angles, power }\r\n                        })\r\n                    }\r\n                    // make all false.\r\n                    isPressed && pressedMap?.actions?.forEach(a => {\r\n                        this.actionState[a] = true;\r\n                    })\r\n                } else {\r\n                    const { degrees } = angles.north0;\r\n                    const dir = getDirectionFromNorth0Degrees(degrees);\r\n                    movedMap && this.updateStickState(angles, power, dir, movedMap);\r\n                    if(isPressed && pressedMap) {\r\n                        this.updateStickState(angles, power, dir, pressedMap);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        updateStickState(0, this.isStickPressed(0));\r\n        updateStickState(1, this.isStickPressed(1));\r\n    }\r\n}","import { InputSystem } from \"../InputSystem\";\r\nimport { StickAction, AddInputIdActionMapEvent, RemoveInputIdActionMapEvent, RangedStickAction, StickInputId } from \"../../types\";\r\nimport { isValidDirection, getDirectionFromNorth0Degrees } from \"../../../utils\";\r\n\r\n\r\n\r\ntype FormattedStickActionLookup = {\r\n    actions?: Array<string>,\r\n    stringDirections?: {\r\n        north?: Array<string>,\r\n        south?: Array<string>,\r\n        east?: Array<string>,\r\n        west?:Array<string>,\r\n        northwest?: Array<string>,\r\n        northeast?: Array<string>,\r\n        southwest?: Array<string>,\r\n        southeast?: Array<string>,\r\n    },\r\n    degreeDirections?: Array<{ min: number, max: number, actions: Array<string> }>\r\n}\r\n\r\nexport abstract class BaseControllerSystem extends InputSystem {\r\n    public gamepad: Gamepad;\r\n    private buttonIndexIdMap: Array<string>;\r\n\r\n    public stickActionCount: {[action: string] : number } = {}\r\n\r\n    private _onMappedStickActionAddedListeners: Array<(event: StickAction) => void> = [];\r\n    private _onMappedStickActionRemovedListeners: Array<(event: StickAction) => void> = [];\r\n\r\n\r\n    readonly mappedStickRotationActions: {[stickIndex: number]: Array<{ start: number, end: number, callback: (rotation: number, power: number) => void }>} = {};\r\n    readonly mappedAxesActions: {[axesIndex: number]: Array<{ start: number, end: number, callback: (rotation: number) => void }>} = {};\r\n    readonly mappedStickActions: { press: Array<FormattedStickActionLookup>, move: Array<FormattedStickActionLookup> } = { press: [], move: [] };\r\n    readonly trackedStickActions: Array<{ press: Array<string>, move: Array<string> }> = [];\r\n    constructor(gamepad: Gamepad, state: any) {\r\n        super();\r\n        this.gamepad = gamepad;\r\n    }\r\n    public onClear(): void {}\r\n\r\n    protected wasTrueLookup: {[action: string]: boolean } = {};\r\n\r\n    public abstract isPowerBtn(buttonIndex: number) : boolean;\r\n    public abstract isStickPressed (stickIndex: number) : boolean;\r\n    public abstract applyControllerState (state: any) : void;\r\n    protected mapStickRangeToAction(axesIndex: number, start: number, end: number, callback: (StickEvent) => void) {\r\n        this.mappedStickRotationActions[axesIndex]\r\n    }\r\n    protected unmapInputFromAction(inputId: string, action: string) : RemoveInputIdActionMapEvent {\r\n        const actions = this.mappedInputIdToActions[inputId];\r\n        if(typeof actions === 'undefined') {\r\n            throw new Error(`The inputId ${inputId} was not mapped to any action.`)\r\n        }\r\n        const eventData : RemoveInputIdActionMapEvent = { inputId, action, actionNowUnmapped: false };\r\n        const idx1 = actions.indexOf(action);\r\n        if(idx1 < 0) {\r\n            throw new Error(`The inputId ${inputId} was not mapped to action ${action}.`)\r\n        }\r\n        actions.splice(idx1, 1);\r\n        if(!actions.length) {\r\n            delete this.mappedInputIdToActions[inputId];\r\n        }\r\n        const idx = this.mappedActionToInputIds[action].indexOf(inputId);\r\n        if(idx < 0) throw new Error(`Index should be greater than -1`);\r\n        this.mappedActionToInputIds[action].splice(idx, 1);\r\n        if(!this.mappedActionToInputIds[action].length) {\r\n            delete this.mappedActionToInputIds[action];\r\n        }\r\n        this._onMappedActionRemovedListeners.forEach(l => l(eventData));\r\n        return eventData;\r\n    }\r\n\r\n    public unmapStickFromAction(stickIndex: number, stickAction: StickAction, press: boolean) {\r\n        if(Array.isArray(stickAction)) {\r\n            stickAction.forEach(a => {\r\n                this.unmapStickFromAction(stickIndex, stickAction, press);\r\n            })\r\n            return;\r\n        }\r\n        const type = this.validateStickActionType(stickAction);\r\n        const stickActions = this.getStickActionLookup(stickIndex, press, false);\r\n        const inputId : StickInputId = { index: stickIndex };\r\n        const eventData : RemoveInputIdActionMapEvent = { inputId, actionNowUnmapped: false, action: '' };\r\n        let actionString;\r\n        if(type === 'string') {\r\n            actionString = stickAction;\r\n            const idx = stickActions.actions.indexOf(actionString);\r\n            if(idx < 0) throw new Error(`Expected`)\r\n            stickActions.actions.splice(idx, 1);\r\n            if(!stickActions.actions.length) {\r\n                delete stickActions.actions;\r\n            }\r\n            eventData.action = actionString;\r\n            this.updateStickActionCount(actionString, false)\r\n            eventData.actionNowUnmapped = !this.actionIsMapped(actionString);\r\n            this._onMappedActionRemovedListeners.forEach(l => l(eventData));\r\n        } else {\r\n            stickAction = (<RangedStickAction>stickAction)\r\n            actionString = stickAction.action;\r\n            const directions = Array.isArray(stickAction.direction) ? stickAction.direction : [stickAction.direction];\r\n            directions.forEach(direction => {\r\n                inputId.direction = direction;\r\n                if(typeof direction === 'string') {\r\n                    const idx = stickActions.stringDirections[direction].indexOf(actionString);\r\n                    if(idx < 0) throw new Error(`Action ${actionString} was not mapped to direction ${direction} on the ${stickIndex} stick`);\r\n                    stickActions.stringDirections[direction].splice(idx, 1);\r\n                    if(!stickActions.stringDirections[direction].length) {\r\n                        delete stickActions.stringDirections[direction];\r\n                        if(!(Object.keys(stickActions.stringDirections).length)) {\r\n                            delete stickActions.stringDirections;\r\n                        }\r\n                    }\r\n                } else {\r\n                    const { min, max } = direction;\r\n                    const found = stickActions.degreeDirections.find(d => d.min == min && d.max == d.max && d.actions.includes(actionString));\r\n                    if(!found) throw new Error(`Action ${actionString} was not mapped to direction min max: ${direction} on the ${stickIndex} stick`);\r\n                    found.actions.splice(found.actions.indexOf(actionString), 1);\r\n                    if(!found.actions.length) {\r\n                        stickActions.degreeDirections.splice(stickActions.degreeDirections.indexOf(found), 1);\r\n                        if(!stickActions.degreeDirections.length) {\r\n                            delete stickActions.degreeDirections;\r\n                        }\r\n                    }\r\n                }\r\n                this.updateStickActionCount(actionString, false)\r\n                eventData.action = actionString;\r\n                eventData.actionNowUnmapped = !this.actionIsMapped(actionString);\r\n                this._onMappedActionRemovedListeners.forEach(l => l(eventData));\r\n            })\r\n        }\r\n    }\r\n    private actionIsMapped(action: string) : boolean {\r\n        if(this.stickActionCount[action]) {\r\n            return true;\r\n        }\r\n        if(this.mappedActionToInputIds[action]?.length) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    private getStickActionLookup(stickIndex: number, isPress: boolean, createIfNotAdded=true) : FormattedStickActionLookup {\r\n        const key = isPress ? 'press' : 'move';\r\n        if(!this.mappedStickActions[key][stickIndex]) {\r\n            if(createIfNotAdded) {\r\n                this.mappedStickActions[key][stickIndex] = {};\r\n            } else {\r\n                throw new Error(`Expected to have index`)\r\n            }\r\n        }\r\n        return this.mappedStickActions[key][stickIndex];\r\n    }\r\n    private validateStickActionType(stickAction: StickAction) : 'string' | 'object' {\r\n        const type = typeof stickAction;\r\n        if(type !== 'string' && type !== 'object') {\r\n            throw new Error(`Invalid action type: ${stickAction}`)\r\n        }\r\n        return type\r\n    }\r\n\r\n    private updateStickActionCount(action: string, add: boolean, press?: boolean) {\r\n        if(add) {\r\n            if(!this.stickActionCount[action]) {\r\n                this.stickActionCount[action] = 1;\r\n            } else {\r\n                this.stickActionCount[action]++;\r\n            }\r\n        } else {\r\n            this.stickActionCount[action]--;\r\n            if(!this.stickActionCount[action]) {\r\n                delete this.stickActionCount[action];\r\n            }\r\n        }\r\n    }\r\n\r\n    public mapStickToAction(stickIndex: number, stickAction: StickAction, press: boolean) {\r\n        if(Array.isArray(stickAction)) {\r\n            stickAction.forEach(a => {\r\n                this.mapStickToAction(stickIndex, a, press);\r\n            })\r\n            return;\r\n        }\r\n        const type = this.validateStickActionType(stickAction);\r\n        const stickActions = this.getStickActionLookup(stickIndex, press, true);\r\n        const inputId : StickInputId = { index: stickIndex };\r\n        const eventData : AddInputIdActionMapEvent = { inputId, action: '' };\r\n        let actionString;\r\n        if(type === 'string') {\r\n            actionString = stickAction;\r\n            if(!stickActions.actions) {\r\n                stickActions.actions = [actionString];\r\n            } else {\r\n                stickActions.actions.push(actionString);\r\n            }\r\n            eventData.action = actionString;\r\n            this.updateStickActionCount(actionString, true)\r\n            this._onMappedActionAddedListeners.forEach(l => l(eventData));\r\n        } else {\r\n            stickAction = (<RangedStickAction>stickAction)\r\n            actionString = stickAction.action;\r\n            const directions = Array.isArray(stickAction.direction) ? stickAction.direction : [stickAction.direction];\r\n            directions.forEach(direction => {\r\n                inputId.direction = direction;\r\n                if(typeof direction === 'string') {\r\n                    if(!isValidDirection(direction)) {\r\n                        throw new Error(`Invalid direction string ${direction}`)\r\n                    }\r\n                    if(!stickActions.stringDirections) {\r\n                        stickActions.stringDirections = {[direction]: [actionString]}\r\n                    } else if (!stickActions.stringDirections[direction]) {\r\n                        stickActions.stringDirections[direction] = [actionString];\r\n                    } else {\r\n                        stickActions.stringDirections[direction].push(actionString);\r\n                    }\r\n                } else {\r\n                    const { min, max } = direction;\r\n                    this.validateMinMax(min, max)\r\n                    if(!stickActions.degreeDirections) {\r\n                        stickActions.degreeDirections = [{ min, max, actions: [actionString] }]\r\n                    } else {\r\n                        const found = stickActions.degreeDirections.find(d => d.min == min && d.max == max);\r\n                        if(found) {\r\n                            found.actions.push(actionString);\r\n                        }else {\r\n                            stickActions.degreeDirections.push({ min, max, actions: [actionString]});\r\n                            stickActions.degreeDirections.sort((aa, bb) => {\r\n                                const aaMin = aa.min || 0;\r\n                                const bbMin = bb.min || 0;\r\n                                return aaMin - bbMin;\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                this.updateStickActionCount(actionString, true)\r\n                eventData.action = actionString;\r\n                this._onMappedActionAddedListeners.forEach(l => l(eventData));\r\n            })\r\n        }\r\n    }\r\n    public updateState(): void {\r\n        this.wasTrueLookup = {};\r\n        this.gamepad.buttons.forEach((b, i) => {\r\n            const resolvedBtnActions = this.resolveActions(i);\r\n            console.log('resolved was', resolvedBtnActions);\r\n            if(!resolvedBtnActions) return;\r\n            if(this.isPowerBtn(i)) {\r\n                resolvedBtnActions.forEach(a => {\r\n                  //  console.error('setting state', a, 'to be', b.value)\r\n                    this.actionState[a] = b.value\r\n                    this.wasTrueLookup[a] = true;\r\n                })\r\n            } else {\r\n                resolvedBtnActions.forEach(a => {\r\n                //    console.error('setting state', a, 'to be', b.pressed)\r\n                    this.actionState[a] = b.pressed;\r\n                    if(b.pressed) {\r\n                        this.wasTrueLookup[a] = true;\r\n                    }\r\n                })\r\n            }\r\n        });\r\n    }\r\n    private validateMinMax(min?: number, max?: number) {\r\n        const hasMin =min !== undefined && min !== null;\r\n        const hasMax = max !== undefined && max !== null;\r\n        if(hasMin) {\r\n            if(min < 0 || min > 360) {\r\n                throw new Error(`Invalid degree value, must be 0-360`)\r\n            }\r\n        }\r\n        if(hasMax) {\r\n            if(max < 0 || max > 360) {\r\n                throw new Error(`Invalid degree value, must be 0-360`)\r\n            }\r\n        }\r\n        if(hasMax && hasMin) {\r\n            if(min >= max) {\r\n                throw new Error(`Min should be less than max.`)\r\n            }\r\n        }\r\n    }\r\n\r\n    protected updateStickState(angles, power, direction: string, stickMap: FormattedStickActionLookup) {\r\n        const { degrees } = angles.north0;\r\n        const dir = getDirectionFromNorth0Degrees(degrees);\r\n        if(stickMap.actions) {\r\n            stickMap.actions.forEach(a => {\r\n                this.actionState[a] = { angles, power }\r\n            })\r\n        }\r\n        if(stickMap.stringDirections) {\r\n            const keys = Object.keys(stickMap.stringDirections);\r\n            keys.forEach(k => {\r\n                stickMap.stringDirections[k].forEach(a => {\r\n                    const wasValid = k === dir;\r\n                    if(wasValid && !this.wasTrueLookup[a]) {\r\n                        this.wasTrueLookup[a] = true;\r\n                        this.actionState[a] = true;\r\n                    } else if (!wasValid && !this.wasTrueLookup[a]) {\r\n                        this.actionState[a] = false;\r\n                    }\r\n                })\r\n            });\r\n        }\r\n        if(stickMap.degreeDirections) {\r\n            for(let i = 0; i < stickMap.degreeDirections.length; i++) {\r\n                const d = stickMap.degreeDirections[i];\r\n                const wasValid = (!d.min || d.min <= degrees) && (!d.max || d.max >= degrees);\r\n                d.actions.forEach(a => {\r\n                    if(wasValid && !this.wasTrueLookup[a]) {\r\n                        this.wasTrueLookup[a] = true;\r\n                        this.actionState[a] = true;\r\n                    } else if (!wasValid && !this.wasTrueLookup[a]) {\r\n                        this.actionState[a] = false;\r\n                    }\r\n                })\r\n            }\r\n        }\r\n    }\r\n}","import { InputSystem } from \"../Systems/InputSystem\";\r\nimport { ActionState, ActionStateDatumChange } from \"../types\";\r\n\r\nexport abstract class BaseManager {\r\n    readonly managedSystems : Array<InputSystem> = [];\r\n    readonly _systemListeners: { 'add': Array<(system: InputSystem) => void>, 'remove' : Array<(system: InputSystem) => void> } = { add: [], remove: [] }\r\n    constructor() {\r\n    }\r\n    public update() : Array<{ state: ActionState, changed: {[action: string]: ActionStateDatumChange } }> {\r\n        this.onUpdate();\r\n        return this.managedSystems.map(s => s.update());\r\n    }\r\n    public clear() {\r\n        this.onClear();\r\n        const systems = [...this.managedSystems];\r\n        systems.forEach(this.removeSystem.bind(this));\r\n    }\r\n    public abstract onUpdate() : void;\r\n    public abstract onClear() : void;\r\n\r\n    public emit(eventname: 'remove' | 'add', system: InputSystem) {\r\n        if(eventname === 'add') {\r\n            this.managedSystems.push(system);\r\n        }\r\n        for(let i = 0; i < this._systemListeners[eventname].length; i++) {\r\n            this._systemListeners[eventname][i](system)\r\n        }\r\n    }\r\n    public addSystem(system: InputSystem) {\r\n        for(let i = 0; i < this._systemListeners['add'].length; i++) {\r\n            this._systemListeners['add'][i](system)\r\n        }\r\n        this.managedSystems.push(system);\r\n    }\r\n    public removeSystem(system: InputSystem) {\r\n        system.onClear();\r\n        for(let i = 0; i < this._systemListeners['remove'].length; i++) {\r\n            this._systemListeners['remove'][i](system)\r\n        }\r\n        const idx = this.managedSystems.indexOf(system);\r\n        idx > -1 && this.managedSystems.splice(idx, 1);\r\n    }\r\n    public on(eventname: 'remove' | 'add', cb: (system: InputSystem) => void) {\r\n        this._systemListeners[eventname].push(cb);\r\n    }\r\n    public off(eventname: 'remove' | 'add', cb: (system: InputSystem) => void) {\r\n        const idx = this._systemListeners[eventname].indexOf(cb);\r\n        idx > -1 && this._systemListeners[eventname].splice(idx, 1);\r\n    }\r\n}","import { InputSystem } from \"../InputSystem\";\r\nimport { MappedActionToInputState } from \"../../types\";\r\n\r\nexport class KeyboardSystem extends InputSystem {\r\n    private actionsFinished : Array<string> = [];\r\n    private actionsStarted : Array<string> = [];\r\n    constructor(state: MappedActionToInputState) {\r\n        super(state);\r\n        this.handleKeyDown = this.handleKeyDown.bind(this);\r\n        this.handleKeyUp = this.handleKeyUp.bind(this);\r\n        window.addEventListener('keydown', this.handleKeyDown)\r\n        window.addEventListener('keyup', this.handleKeyUp)\r\n    }\r\n    public updateState(): void {\r\n        this.actionsFinished.forEach(a => {\r\n            this.actionState[a] = false;\r\n        });\r\n        this.actionsStarted.forEach(a => {\r\n            this.actionState[a] = true;\r\n        })\r\n        this.actionsStarted.length = 0;\r\n        this.actionsFinished.length = 0;\r\n    }\r\n    private handleKeyDown(event: KeyboardEvent) {\r\n        const actions = this.resolveActions(event.code);\r\n        actions && this.actionsStarted.push(...actions);\r\n    }\r\n    private handleKeyUp(event: KeyboardEvent) {\r\n        const actions = this.resolveActions(event.code);\r\n        actions && this.actionsFinished.push(...actions);\r\n    }\r\n    public onClear(): void {\r\n        window.removeEventListener('keydown', this.handleKeyDown);\r\n        window.removeEventListener('keyup', this.handleKeyUp);\r\n    }\r\n}","import { InputSystem } from \"../InputSystem\";\r\nimport { MappedActionToInputState } from \"../../types\";\r\n\r\nexport class MouseSystem extends InputSystem {\r\n    private actionsFinished : Array<string> = [];\r\n    private actionsStarted : Array<string> = [];\r\n\r\n    constructor(state?: MappedActionToInputState) {\r\n        super(state);\r\n        this.handleMouseDown = this.handleMouseDown.bind(this);\r\n        this.handleMouseUp = this.handleMouseUp.bind(this);\r\n        this.handleMouseMove = this.handleMouseMove.bind(this);\r\n\r\n        window.addEventListener('mousedown', this.handleMouseDown);\r\n        window.addEventListener('mouseup', this.handleMouseUp);\r\n        window.addEventListener('mousemove', this.handleMouseMove);\r\n    }\r\n    public updateState(): void {\r\n        this.actionsFinished.forEach(a => {\r\n            this.actionState[a] = false;\r\n        });\r\n        this.actionsStarted.forEach(a => {\r\n            this.actionState[a] = true;\r\n        })\r\n        this.actionsStarted.length = 0;\r\n        this.actionsFinished.length = 0;\r\n    }\r\n    private handleMouseMove(event: MouseEvent) {\r\n    }\r\n    private handleMouseDown(event: MouseEvent) {\r\n        const actions = this.resolveActions(event.button);\r\n        actions &&  this.actionsStarted.push(...actions);\r\n    }\r\n    private handleMouseUp(event: MouseEvent) {\r\n        const actions = this.resolveActions(event.button);\r\n        actions && this.actionsFinished.push(...actions);\r\n    }\r\n    public onClear(): void {\r\n        window.removeEventListener('mousedown', this.handleMouseDown);\r\n        window.removeEventListener('mouseup', this.handleMouseUp);\r\n        window.removeEventListener('mousemove', this.handleMouseMove);\r\n    }\r\n}"],"sourceRoot":""}